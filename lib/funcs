#!/bin/sh

drive_words='desktop,solid,state,ssd,series,digital,product,size,model,pro,iii,bare,buy,cache,hard,item,mtc,scan,internal,external,drive,hdd,sdd,storage,bay,bios,rpm,sata,technology,rate,nas,oem,pc,amazon,'
stop_words='a,able,about,across,after,all,almost,also,am,among,an,and,any,are,as,at,be,because,been,but,by,can,cannot,could,dear,did,do,does,either,else,ever,every,for,from,get,got,had,has,have,he,her,hers,him,his,how,however,i,if,in,into,is,it,its,just,least,let,like,likely,may,me,might,most,must,my,neither,no,nor,not,of,off,often,on,only,or,other,our,own,rather,said,say,says,she,should,since,so,some,than,that,the,their,them,then,there,these,they,this,tis,to,too,twas,us,wants,was,we,were,what,when,where,which,while,who,whom,why,will,with,would,yet,you,your'
avoid_words=$stop_words','$drive_words

#
# Functions
#

trim () {
    echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

echo_err () {
   echo "[ERROR] $@" >&2
}

# ARGS: $1 - model string from parted i.e. ATA KINGSTON SV300S3, ATA ST3000DM001-1CH1 etc
# OUTPUTS: the proper name of the vendor
get_vendor () {
    if [ -n "`echo $1 | egrep '^(ATA) +ST'`" ]; then
        echo SEAGATE
    fi

    if [ -n "`echo $1 | grep -i kingston`" ]; then
        echo KINGSTON
    fi

    if [ -n "`echo $1 | grep -i ocz`" ]; then
        echo OCZ
    fi
}

# ARGS: $1 - model string from parted i.e. ATA KINGSTON SV300S3, ATA ST3000DM001-1CH1 etc
# OUTPUTS: the proper name of the model
get_model () {
    local vendor=$(get_vendor "$1")
    echo $1 | sed -e 's/ATA //g' -e 's/'$vendor'//g' -e 's/ //g' -e 's/-.*//'
}

# ARGS: $1 - parted disk size value inside i.e. 3 TB, 3000GB, 23949583M etc
# OUTPUTS: amount in megabytes as just a numeric string
in_mb () {
    # values from parted are in GB so let us confirm
    if [ -z "echo $1 | grep GB" ]; then
        echo_err "Failed to detect units in disk size: $1"
        exit 1
    fi

    gb=`echo $1 | sed -e 's/GB//'`
    echo $(($gb * 1000))
}

# ARGS: $1 - drive vendor
# ARGS: $2 - drive model
# OUTPUTS: returns first matching URL of a PDF file from the vendor
drive_datasheet () {
    urls=`googler --json $1 $2 datasheet | grep url | cut -d ' ' -f 2 | sed -e 's/^"//' -e 's/"$//'`
    for url in $urls; do
        if [ -n "`echo $url | grep -i .pdf | grep -i $vendor'.com'`" ]; then
            echo $url
            return
        fi
    done
}

# ARGS: $1 - drive vendor
# ARGS: $2 - drive model
# OUTPUTS: family <space> series, if they exist
drive_family_series () {
    local vendor="$1"
    local model="$2"
    local names=`googler --json buy "$vendor" "$model"      \
     | grep -oP "\w*[A-Z]+\w*"                              \
     | tr '[:upper:]' '[:lower:]'                           \
     | grep '^[a-z]' | sort`
    
    local histfile=`mktemp`
    for name in $names; do 
        if [ -z "`echo $avoid_words | grep $name`" ]; then 
            echo $name;
        fi; 
    done | uniq -c | grep -v -i "$vendor" | grep -v -i "$model" | sort -g -r > $histfile

    local prevfreq=-1
    local prevword=''
    local words=()
    while read line; do
        freq=`echo $line | cut -d ' ' -f 1`
        word=`echo $line | cut -d ' ' -f 2`

        if [ $prevfreq -eq -1 ]; then
            prevfreq=$freq
            prevword=$word
            words+=($word)
        elif [ $(($prevfreq / $freq)) -lt 2 ]; then
            words+=($word)
        fi
    done < $histfile
    rm $histfile

    # the series is closer to the model so it is more common if there is 
    # one at all, that's why we send back family series in this order
    if [ ${#words[@]} -gt 1 ]; then
        echo "${words[1]} ${words[0]}"
    else
        echo "${words[0]} ${words[0]}"
    fi
}

# ARGS: $1 - simple device name after /dev/: i.e. sda
# OUTPUTS: [ata | usb] or zero string
bus_type () {
    udevadm info --query=property --path=/sys/block/$1 | grep ^ID_BUS | cut -d '=' -f 2
}

# ARGS: none
# OUTPUTS: list of block sys devices one per line or zero string: i.e. /sys/block/sdc
ata_drives () {
    for device in /sys/block/*; do
        if udevadm info --query=property --path=$device | grep -q ^ID_BUS=ata; then
            echo $device;
        fi;
    done
}

# ARGS: none
# OUTPUTS: the device if any or zero string: i.e. /dev/sdc
usb_drive () {
    for device in /sys/block/*; do
        if udevadm info --query=property --path=$device | grep -q ^ID_BUS=usb; then
            echo $device;
            return
        fi;
    done
}

# ARGS: $1 - simple device name after /dev/: i.e. sda
# OUTPUTS: [true|false] as a string
is_hdd () {
    local dev="$1"
    local type=`bus_type $dev`
    local desc=`lshw -businfo -class disk | grep $dev | \
         cut -d ' ' -f 4,5,6 | egrep '[a-z]|[A-Z]|[0-9]+'`

    if [ -z "$desc" ]; then # -o "$type" == "usb" ]; then
        echo "false no desc"
        return
    fi

    # SSD might show rotational to 1, but HDD never will show 0
    if [ "`cat /sys/block/$dev/queue/rotational`" == "0" ]; then
        echo "false"
        return
    fi

    # If it says it's rotational then check with google for no ssd references
    local ssd_hits=`googler -n 100 --json $desc | grep -i ssd | wc | cut -d ' ' -f 1`
    local hdd_hits=`googler -n 100 --json $desc | grep -i hdd | wc | cut -d ' ' -f 1`
    local ratio=$(($hdd_hits / $ssd_hits))

    if [ $ratio -gt $THRESHOLD ]; then
        echo "true"
    else 
        echo "false"
    fi
}

# ARGS: $1 the simple device name: i.e. sda
# OUTPUTS: the udev device path
dev_path () {
    udevadm info --query=property --path=/sys/block/"$1" | grep -i devpath | cut -d '=' -f 2
}

# ARGS: path to folder for pvms
# OUTPUTS: dmi_processor.txt file
dmi_processor () {
    local outputfile="$1"'/dmi_processor.txt'
    dmidecode > dmidecode.txt
    mode='out'
    while read line; do
        if [ -n "`echo $line | grep 'Processor Information'`" ]; then
            mode='in'
            echo $line > $outputfile
            continue
        fi

        if [ "$mode" == "in" ]; then
            if [ -z "$line" ]; then
                mode='out'
            fi

            if [ -z "`echo $line | grep :`" ]; then
                echo '    '$line >> $outputfile
            else
                echo '  '$line >> $outputfile
            fi
        fi
    done < dmidecode.txt
    rm dmidecode.txt
}

# ARGS: path to folder for pvms
# OUTPUTS: cpu_info.txt file
cpu_info () {
    local outputfile="$1"'/cpu_info.txt'
    local CORES=`cat /proc/cpuinfo | grep processor | wc | cut -d ' ' -f 1`
    local pattern='^processor.*:.*'$(($CORES - 1))
    local mode='out'

    while read line; do
        if [ -n "`echo $line | egrep $pattern`" ]; then
            mode='in'
        fi

        if [ "$mode" == "in" ]; then
            echo $line >> $outputfile
        fi
    done < /proc/cpuinfo
}

