
#
# Functions
#

di () {
  test -d /target
}

upper () {
  echo "$1" | tr '[:lower:]' '[:upper:]'
}

lower () {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

trim () {
    echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

err () {
   echo "[ERROR] $@" >&2
}

warn () {
   echo "[WARNING] $@" >&2
}

info () {
   echo "[INFO] $@" >&2
}

# ARGS: $1 - normalize size values into megabytes 3 TB, 3000GB, 23949583M etc
# OUTPUTS: amount in megabytes as a numeric string
in_mb () {
    # values from parted are in GB so let us confirm
    if [ -z "echo $1 | grep GB" ]; then
        err "Failed to detect units in input size: $1"
        exit 1
    fi

    gb=`echo $1 | sed -e 's/GB//'`
    echo $(($gb * 1000))
}

# ARG $1: the name of the debug step 'touch /tmp/$1' to continue
# ARG $1: optional message to put into message file in /tmp/debug.$name.message
# OUTPUT: if DEBUG is 'enabled' this call will block indefinitely waiting for
#         a file touch in /tmp named after the debug step provided in $1
debug_step () {
  local lock_file="/tmp/debug.$1"
  local message_file="/tmp/debug.$1"'.message'

  if [ "$DEBUG" != 'enabled' ]; then
    return 0
  fi

  rm -f "$lock_file"
  rm -f "$message_file"
  echo "[DEBUG] blocking waiting for \'touch $lock_file\'" > "$message_file"

  if [ -n "$2" ]; then
    echo "[DEBUG] $2" >> "$message_file"
  fi

  while true; do
    if [ -f "$lock_file" ]; then
      rm "$lock_file"
      rm "$message_file"
      break;
    fi

    sleep 1
  done
}

