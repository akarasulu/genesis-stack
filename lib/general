
#
# Functions
#

if [ -z "$loglevel" ]; then
  loglevel=4
fi

di () {
  test -d /target
}

upper () {
  echo "$1" | tr '[:lower:]' '[:upper:]'
}

lower () {
  echo "$1" | tr '[:upper:]' '[:lower:]'
}

trim () {
    echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

err () {
   if [ $loglevel -gt 0 ]; then
     echo "[ERROR] $@" >&2
   fi
}

warn () {
   if [ $loglevel -gt 1 ]; then
     echo "[WARNING] $@" >&2
   fi
}

info () {
   if [ $loglevel -gt 2 ]; then
     echo "[INFO] $@" >&2
   fi
}

debug () {
   if [ $loglevel -gt 3 ]; then
     echo "[DEBUG] $@" >&2
   fi
}

# ARGS: $1 - normalize size values into megabytes 3 TB, 3000GB, 23949583M etc
# OUTPUTS: amount in megabytes as a numeric string
in_mb () {
    # values from parted are in GB so let us confirm
    if [ -z "echo $1 | grep GB" ]; then
        err "Failed to detect units in input size: $1"
        exit 1
    fi

    gb=`echo $1 | sed -e 's/GB//'`
    echo $(($gb * 1000))
}

# ARG $1: the name of the debug step 'touch /tmp/$1' to continue
# ARG $1: optional message to put into message file in /tmp/debug.$name.message
# OUTPUT: if DEBUG is 'enabled' this call will block indefinitely waiting for
#         a file touch in /tmp named after the debug step provided in $1
debug_step () {
  local lock_file="/tmp/debug.$1"
  local message_file="/tmp/debug.$1"'.message'

  if [ "$DEBUG" != 'enabled' ]; then
    return 0
  fi

  rm -f "$lock_file"
  rm -f "$message_file"
  echo "[DEBUG] blocking waiting for creation of $lock_file" > "$message_file"

  if [ -n "$2" ]; then
    echo "[DEBUG] $2" >> "$message_file"
  fi

  while true; do
    if [ -f "$lock_file" ]; then
      contents="$(cat $lock_file)"
      echo "[DEBUG] found contents of $lock_file = $contents" >&2
      if [ "$contents" == '-x' ]; then
        set -x
      elif [ "$contents" == '+x' ]; then
        set +x
      fi

      rm "$lock_file"
      rm "$message_file"
      break;
    fi

    sleep 1
  done
}

debug_loop () {
  echo "[DEBUG] Debug loop started." >&2
  while true; do
    sleep 1;
    if [ -n "$(ls /tmp | grep *.message)" ]; then
      file="$(ls /tmp | grep -o 'debug\..*\.message' | head -n 1)"
      if [ -z "$file" ]; then
        continue;
      fi

      op="$(echo $file | sed -e 's/\.message$//' -e 's/^debug\.//')"
      cat "/tmp/$file" >&2
      echo "Use -x/+x before <enter> to toggle debugging. Continue with $op operation?" >&2
      read input;

      if [ -n "$input" ]; then
        echo "$input" > /tmp/debug.$op
      else 
        touch /tmp/debug.$op; 
      fi
    fi; 
  done
}

