
# 
# WARNING: This library was designed to run inside BusyBox (ash shell)
# -------  so make sure changes don't break that!
# 

# copied from general to reduce dependencies
trim () {
    echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

# ARGS: $1 - model string from parted i.e. ATA KINGSTON SV300S3, ATA ST3000DM001-1CH1 etc
# OUTPUTS: the proper name of the vendor
disk_vendor () {
  if [ -n "`echo $1 | egrep '^(ATA) +ST'`" ]; then
    echo SEAGATE
  fi

  if [ -n "`echo $1 | grep -i kingston`" ]; then
    echo KINGSTON
  fi

  if [ -n "`echo $1 | grep -i ocz`" ]; then
    echo OCZ
 fi
}

# ARGS: $1 - model string from parted i.e. ATA KINGSTON SV300S3, ATA ST3000DM001-1CH1 etc
# OUTPUTS: the proper name of the model
disk_model () {
  local vendor=$(disk_vendor "$1")
  echo $1 | sed -e 's/ATA //g' -e 's/'$vendor'//g' -e 's/ //g' -e 's/-.*//'
}

# ARGS: $1 - simple device name after /dev/: i.e. sda
# OUTPUTS: [ata | usb] or zero string
disk_bus () {
  udevadm info --query=property --path=/sys/block/$1 | grep ^ID_BUS | cut -d '=' -f 2
}

# ARGS: none
# OUTPUTS: list of scsi block deviceIds one per line or zero string: i.e. /sys/block/sdc
disk_scsi_drives () {
  local device='';
  for device in /sys/block/*; do
    if udevadm info --query=property --path="$device" | grep -q '^ID_BUS=scsi'; then
      echo $(basename $device);
    fi;
  done
}

# ARGS: none
# OUTPUTS: list of scsi block deviceIds one per line or zero string: i.e. /sys/block/sdc
disk_ata_drives () {
  local device='';
  for device in /sys/block/*; do
    if udevadm info --query=property --path="$device" | grep -q '^ID_BUS=ata'; then
      echo $(basename $device);
    fi;
  done
}

# ARGS: none
# OUTPUTS: the device if any or zero string: i.e. /dev/sdc
disk_usb_drive () {
  local device=''
  for device in /sys/block/*; do
    if udevadm info --query=property --path="$device" | grep -q '^ID_BUS=usb'; then
      echo $(basename $device);
      return
    fi;
  done
}

# ARGS: $1 the simple device name: i.e. sda
# OUTPUTS: the udev device path
disk_dev_path () {
  udevadm info --query=property --path=/sys/block/"$1" | grep -i devpath | cut -d '=' -f 2
}

#
# Disk Operations w/ fdisk
#

# ARGS $1: the drive device i.e. /dev/sda to write GPT partition to
fdisk_gpt () {
  local dev="$1"

  if [ -z "$(echo $1 | egrep '^/dev/')" ]; then
    dev="/dev/$1"
  fi

echo "g
w
"|fdisk "$dev"
}

# ARGS $1: the drive device i.e. /dev/sda to delete a partition from
fdisk_del () {
  local dev="$1"

  if [ -z "$(echo $1 | egrep '^/dev/')" ]; then
    dev="/dev/$1"
  fi

echo "d
w
"|fdisk "$dev"
}

# ARGS $1: the partition device ID i.e. sda1 to explicitly delete
fdisk_part_del () {
  local part="$(echo $1 | egrep -o '[0-9]+$')"
  local dev="$(echo $1 | sed -e 's/[0-9]\+$//')"

  if [ -z "$(echo $dev | egrep '^/dev/')" ]; then
    dev="/dev/$dev"
  fi
  echo "dev = $dev, part = $part" 
echo "d
$part
w
"|fdisk "$dev"
}

fdisk_raid () {
  local drive_dev="$(echo $1 | sed -e 's/[0-9]\+$//')"
  debug "drive_dev = $drive_dev"

  local pt="$(pttype $drive_dev)"
  debug "pt = $pt"

  local part_num="$(echo $1 | egrep -o '[0-9]+$')"
  debug "part_num = $part_num"

  local size="$2"
  debug "size = $size"

  local code=''

  if [ "$pt" == "dos" ]; then
    code="fd"
  else 
    code="29"
  fi

  debug "code = $code"

  # check if /dev/ is NOT prefixed and if NOT add it
  if [ -z "$(echo $drive_dev | egrep '^/dev/')" ]; then
    drive_dev="/dev/$drive_dev"
  fi

  debug "Full drive_dev = $drive_dev"
  
  if [ -n "$size" -a "$pt" == "dos" ]; then
echo "n
p
$part_num

+$size
t
$part_num
$code
w
"|fdisk "$drive_dev"
  elif [ -n "$size" -a "$pt" == "gpt" ]; then
echo "n
$part_num

+$size
t
$part_num
$code
w
"|fdisk "$drive_dev"
  elif [ "$pt" == "dos" ]; then
echo "n
p
$part_num


t
$part_num
$code
w
"|fdisk "$drive_dev"
  else
echo "n
$part_num


t
$part_num
$code
w
"|fdisk "$drive_dev"
  fi
}

# ARGS $1: the drive device i.e. /dev/sda to create a primary partition on
# ARGS $2: the size of the partition in sectors or in bytes scale accepted by fdisk
fdisk_primary () {
  local dev="$1"
  local sectors="$2"

  if [ -z "$(echo $1 | egrep '^/dev/')" ]; then
    dev="/dev/$1"
  fi


  if [ -n "$sectors" ]; then
echo "n
p


+$sectors
w
"|fdisk "$dev"
  else 
echo "n
p



w
"|fdisk "$dev"
  fi
}

# ARGS $1: the drive device to get the partition type of: gpt or dos
pttype () {
  local dev="$1"

  if [ -z "$(echo $1 | egrep '^/dev/')" ]; then
    dev="/dev/$1"
  fi

  fdisk -l "$dev" | egrep '^Disklabel type:' | sed -e 's/Disklabel type: //'
}

# ARGS $1: the drive device partition i.e. /dev/sda2 to create a LVM partition on
# ARGS $2: the size in sectors or megabytes
fdisk_lvm () {
  local drive_dev="$(echo $1 | sed -e 's/[0-9]\+$//')"
  debug "drive_dev = $drive_dev"

  local pt="$(pttype $drive_dev)"
  debug "pt = $pt"

  local part_num="$(echo $1 | egrep -o '[0-9]+$')"
  debug "part_num = $part_num"

  local size="$2"
  debug "size = $size"

  local code=''

  if [ "$pt" == "dos" ]; then
    code="8e"
  else 
    code="31"
  fi

  debug "code = $code"

  # check if /dev/ is NOT prefixed and if NOT add it
  if [ -z "$(echo $drive_dev | egrep '^/dev/')" ]; then
    drive_dev="/dev/$drive_dev"
  fi

  debug "Full drive_dev = $drive_dev"
  
  if [ -n "$size" -a "$pt" == "dos" ]; then
echo "n
p
$part_num

+$size
t
$part_num
$code
w
"|fdisk "$drive_dev"
  elif [ -n "$size" -a "$pt" == "gpt" ]; then
echo "n
$part_num

+$size
t
$part_num
$code
w
"|fdisk "$drive_dev"
  elif [ "$pt" == "dos" ]; then
echo "n
p
$part_num


t
$part_num
$code
w
"|fdisk "$drive_dev"
  else
echo "n
$part_num


t
$part_num
$code
w
"|fdisk "$drive_dev"
  fi
}


# ARGS $1: the drive device i.e. /dev/sda to create a LVM partition on
# ARGS $2: the size in sectors or megabytes
fdisk_lvm_p1 () {
  local dev="$1"
  local sectors="$2"
  local code="8e"

  if [ "$(pttype $1)" == "gpt" ]; then
    code="31"
  fi

  if [ -z "$(echo $1 | egrep '^/dev/')" ]; then
    dev="/dev/$1"
  fi

 if [ -n "$sectors" ]; then
echo "n
p


+$sectors
t
$code
w
"|fdisk "$dev"
  else 
echo "n
p



t
$code
w
"|fdisk "$dev"
  fi
}


# ARGS $1: the drive device i.e. /dev/sda to create a LVM partition on
# ARGS $2: the size in sectors or megabytes
fdisk_lvm_p2 () {
  local dev="$1"
  local sectors="$2"
  local code="8e"

  if [ -z "$(echo $1 | egrep '^/dev/')" ]; then
    dev="/dev/$1"
  fi

  if [ "$(pttype $1)" == "gpt" ]; then
    code="31"
  fi  

 if [ -n "$sectors" ]; then
echo "n
p


+$sectors
t

$code
w
"|fdisk "$dev"
  else 
echo "n
p



t

$code
w
"|fdisk "$dev"
  fi
}

# ARGS: none, backs up the root filesystem
# Presumes a single USB drive is attached
back2usb () {
  # 4th USB drive partition for backup (created in process)
  local partition='/dev/'"$(disk_usb_drive)"4
  mount "$partition" /mnt
  mkdir /mnt/root

  # Unmount boot and backup
  umount -l /target/boot
  cd /target
  tar cf - . | (cd /mnt/root && tar xf -)
  cd /
}

# Unmounts (forcefully) all filesystems and swap 
unmount_fs () {
  swap_dev="$(lvdisplay | grep swap | sed -e 's/ //g' | grep LVPath | sed -e 's/LVPath//g')"
  swapoff "$swap_dev"
  umount -l /dev/.static/dev
  umount -l /target
}

# Wipes clean all lvm entities
wipe_lvm () {
  cd /

  # back up to reconstruct
  lvdisplay > /mnt/lvdisplay.out
  lvs > /mnt/lvs.out
  vgdisplay > /mnt/vgdisplay.out
  vgs > /mnt/vgs.out

  vg="$(vgs | grep -v '#PV' | sed -e 's/  //g' | cut -d ' ' -f 1)"
  lvs="$(lvs | grep -v 'LSize' | sed -e 's/  //g' | cut -d ' ' -f 1)"
  pv="$(pvdisplay | sed -e 's/ //g' | grep PVName | sed -e 's/PVName//g')"

  for lv in $lvs; do
    lvremove -f "/dev/$vg/$lv"
  done

  vgremove -f $vg
  pvremove $pv
}

# Lists all drives by deviceId minus USB and cdrom
list_drives () {
  local cdrom='sr0'
  local usb=$(disk_usb_drive)
  local drives=''

  for d in $(disk_scsi_drives); do
    if [ "$d" != "$cdrom" -a "$d" != "$usb" ]; then
      drives="$drives $d"
    fi
  done

  for d in $(disk_ata_drives); do
    if [ "$d" != "$cdrom" -a "$d" != "$usb" ]; then
      drives="$drives $d"
    fi
  done

  echo $(trim "$drives")
}

# ARG $1: optional, anything non-zero prints histogram with counts field,
#         without it prints just the unique capacities
# OUPUTS: Lists unique disk capacities (not USB) as reported by parted_devices
#         in DI with total device count for each capacity. The size output is
#         in bytes (original figure from parted_devices) for the disks. The 
#         same disks should report the same capacities.  
uniq_capacities () {
  if [ -n "$1" ]; then
    parted_devices | grep -v $(disk_usb_drive) | sed -e 's/\t/ /g' | cut -d' ' -f2 | sort | uniq -c
  else
    parted_devices | grep -v $(disk_usb_drive) | sed -e 's/\t/ /g' | cut -d' ' -f2 | sort | uniq
  fi
}

drives_for_capacity () {
    local cap="$1"
    parted_devices | grep -v $(disk_usb_drive) | grep $cap | sed -e 's/\t/ /g' -e 's@/dev/@@' | cut -d' ' -f1
}

drive_sets () {
  local cap=0
  local drives=''
  local count=0

  for cap in $(uniq_capacities); do
    cap=$(trim $cap)
    for d in $(drives_for_capacity $cap); do
      d=$(trim $d)
      drives="$drives,$d"
      count=$((count + 1))
    done
      
    drives=$(echo $drives | sed -e 's/^,//')
    cap=$((cap / 1024 / 1024))
    echo "$cap $count $drives"
    drives=''
    count=0
  done
}

# ARG $1: the deviceId of the drive (i.e. sda)
# OUTPUT: the size of the drive in Megabytes (1024 not 1000 based)
# Uses parted_devices available in DI to get drive capacity
parted_capacity () {
  local capacity=0
  local drive="$1"

  capacity="$(parted_devices | grep $drive | sed -e 's/\t/ /g' | cut -d' ' -f2)"
  capacity=$((capacity / 1024 / 1024))
  echo "$capacity"
}

boot_partition () {
  if [ -f /tmp/boot_partition ]; then
    cat /tmp/boot_partition
  else
    grep '/boot' /proc/mounts | cut -d' ' -f1 > /tmp/boot_partition
    cat /tmp/boot_partition
  fi
}

boot_drive () {
    boot_partition | sed -e 's@/dev/@@' | egrep -o '[a-z]{3}'
}

build_md0 () {
  local devs="$1"
}

# ARG $1: a list of devices in the raid set to create
build_md1 () {
  local devs="$1"
}

prep_boot_drive () {
  # IMPORTANT NOTE
  #
  # The partition manager takes different strategies based on the nature
  # of a single drive. If large it uses a GPT partition table. If small 
  # it uses a dos partition table. And the partitions and number of them
  # that are created are different based on the size.
  #
  # For large single drive configurations DI seems to be creating 3 different
  # partitions on the single drive with the boot partition set to sda2, the
  # second partition. Here's what the fdisk of a large drive looks like:
  #
  # ~ # fdisk -l /dev/sda
  # Disk /dev/sda: 2.9 TiB, 3146776576000 bytes, 6146048000 sectors
  # Units: sectors of 1 * 512 = 512 bytes
  # Sector size (logical/physical): 512 bytes / 512 bytes
  # I/O size (minimum/optimal): 512 bytes / 512 bytes
  # Disklabel type: gpt
  # Disk identifier: 093345E8-6FB0-4D97-978F-D13717B39EC4
  # 
  # Device      Start        End    Sectors  Size Type
  # /dev/sda1    2048       4095       2048    1M BIOS boot
  # /dev/sda2    4096     503807     499712  244M Linux filesystem
  # /dev/sda3  503808 6146045951 6145542144  2.9T Linux LVM
  #
  # When a smaller drive with a dos partition table is used the boot partition
  # is the first partition rather than the second. An extended partition is
  # used with the #2 and #5 lvm partition:
  # 
  # ~ # fdisk -l /dev/sda
  # Disk /dev/sda: 234.4 GiB, 251658240000 bytes, 491520000 sectors
  # Units: sectors of 1 * 512 = 512 bytes
  # Sector size (logical/physical): 512 bytes / 512 bytes
  # I/O size (minimum/optimal): 512 bytes / 512 bytes
  # Disklabel type: dos
  # Disk identifier: 0x33834c96
  # 
  # Device     Boot  Start       End   Sectors   Size Id Type
  # /dev/sda1  *      2048    499711    497664   243M 83 Linux
  # /dev/sda2       501758 491517951 491016194 234.1G  5 Extended
  # /dev/sda5       501760 491517951 491016192 234.1G 8e Linux LVM
  #

  # We will make decisions based on the partition type of the drive
  # as does the Debian Installer partition manager.
  local bd=$(boot_drive)
  local pt="$(pttype $bd)"
  debug "Boot Disk $bd Partition Table Type: $pt"

  if [ "$pt" == "dos" ]; then
    # We destroy the 2nd and 5th extended partitions in reverse order
    fdisk_part_del       '/dev/'$bd'5'
    fdisk_part_del       '/dev/'$bd'2'
    echo 2 > /tmp/next_part
  elif [ "$pt" == "gpt" ]; then
    fdisk_part_del       '/dev/'$bd'3'
    echo 3 > /tmp/next_part
  else
    error "Do not know what to do with partition type of $pt"
    error "Returning nonzero ..."
    return 1
  fi
} 

calc_sys_size () {
  local ratio="$1"
  local total="$2"
  local sys_part="$(echo $ratio | cut -d ':' -f 1)"
  local data_part="$(echo $ratio | cut -d ':' -f 2)"
  local total_parts="$((sys_part + data_part))"
  local sys_part_float="$(echo $sys_part / $total_parts | bc -l)"
  echo 'scale=0; '"$sys_part_float * $total" | bc -l | cut -d '.' -f 1
}

size_difference () {
    local smaller
    local larger
    local diff

    if [ $1 -gt $2 ]; then
      larger="$1"
      smaller="$2"
    else 
      larger="$2"
      smaller="$1"
    fi

    echo "scale=2; ( ( $larger - $smaller ) / $larger ) * 100" | bc -l
}

# ARG $1: the drive's deviceId (i.e. sda, sdc, etc)
# OUTPUT: the unmodified parted_devices value in bytes for the drive capacity
drive_capacity () {
  parted_devices | grep "$1" | sed -e 's/\t/ /g' | cut -d' ' -f2
}

# ARG $1: the file system device
# ARG $2: the file system type string (ext4, ext3, ext2, btrfs, fat, jfs, xfs)
mkfs () {
  mkfs."$2" -f 
}
